---
title: "1ï¸âƒ£9ï¸âƒ£ Climbing Stairs"
description: "Brute force, memoization, tabulation, and optimal DP approach for Climbing Stairs â€” with code, intuition, real-world examples, complexity analysis."
---

#  Climbing Stairs â€” Dynamic Programming

The **Climbing Stairs** problem is a classic DP question and a favorite in coding interviews.

### ğŸ“Œ Problem  
You are climbing a staircase with **n steps**.  
You can climb **1 step or 2 steps** at a time.  
Return the **number of distinct ways** to reach the top.

---

# ğŸ§  Real-World Examples

### ğŸªœ 1. Gym Exercise Combinations  
Count ways to complete a workout using 1-step or 2-step routines.

### ğŸ’¡ 2. Tiling Problems  
Ways to fill a floor of size `n` using tiles of size 1 and 2.

### ğŸ” 3. Decoding Algorithms  
Same logic used in "Decode Ways" problem.

### ğŸ“± 4. App Onboarding Screens  
Choosing 1-step or 2-step navigation patterns.

---

# ğŸŒ Brute Force â€” Recursion (Exponential Time)

### ğŸ§© Idea  
Try all possibilities:

```

ways(n) = ways(n-1) + ways(n-2)

````

### âŒ Problem  
Recalculates same subproblems many times.  
**Time: O(2â¿)** (very slow)

### Code

```js
function climbStairsBrute(n) {
  if (n <= 2) return n;
  return climbStairsBrute(n - 1) + climbStairsBrute(n - 2);
}
````

---

# âš™ï¸ Better Approach â€” Recursion + Memoization (Top-Down DP)

### ğŸ§© Idea

Store results of subproblems to avoid recomputation.

### Code

```js
function climbStairsMemo(n, memo = {}) {
  if (n <= 2) return n;
  if (memo[n]) return memo[n];

  memo[n] = climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo);
  return memo[n];
}
```

### ğŸŸ¢ Improved to **O(n)** time

### ğŸŸ¢ Space becomes **O(n)** due to recursion + memo.

---

# ğŸ“¦ Optimal DP â€” Tabulation (Bottom-Up)

### ğŸ§© Idea

Build the solution iteratively using a DP array.

### Code

```js
function climbStairsDP(n) {
  if (n <= 2) return n;

  const dp = Array(n + 1).fill(0);
  dp[1] = 1;
  dp[2] = 2;

  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}
```

### Complexity

| Time | Space |
| ---- | ----- |
| O(n) | O(n)  |

---

# âš¡ Optimal Approach â€” Space Optimized Fibonacci

### ğŸ§© Insight

The recurrence:

```
ways(n) = ways(n-1) + ways(n-2)
```

â€¦is exactly the Fibonacci sequence.

So we only need the last two values.

### âœ” Most optimal approach

### âœ” Constant space

### âœ” O(n) time

### Code

```js
function climbStairs(n) {
  if (n <= 2) return n;

  let prev2 = 1; // ways for step 1
  let prev1 = 2; // ways for step 2

  for (let i = 3; i <= n; i++) {
    let current = prev1 + prev2;
    prev2 = prev1;
    prev1 = current;
  }

  return prev1;
}
```

---

# ğŸ§¾ Final Complexity Comparison

| Approach                         | Time     | Space    |
| -------------------------------- | -------- | -------- |
| Brute Force Recursion            | âŒ O(2â¿)  | O(n)     |
| Memoization                      | O(n)     | O(n)     |
| DP Tabulation                    | O(n)     | O(n)     |
| **Space-Optimized DP (Optimal)** | **O(n)** | **O(1)** |

---

# ğŸ¯ Interview Tips

* Explain recurrence:
  `ways(n) = ways(n-1) + ways(n-2)`
* Mention similarity to **Fibonacci**.
* State why brute force fails (overlapping subproblems).
* Show progression from recursion â†’ memo â†’ tabulation â†’ optimized.
* If asked to extend (steps of 1,2,3), you can easily modify DP.

---