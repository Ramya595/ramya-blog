---
title: "6ï¸âƒ£Merge Two Sorted Lists"
description: "Brute force, better approach, optimal pointer-based linked list merging, complexity analysis, and real-world use cases."
tags:
  - DSA
  - Linked Lists
  - Pointers
  - Algorithms
  - Problem Solving
---

import { Callout } from "fumadocs-ui/components/callout";

# ğŸ”— Merge Two Sorted Lists â€” Classic Linked List Merge Technique

Merging two sorted linked lists is a foundational DSA problem that teaches you how to work with pointers efficiently.  
This is also a core part of **merge sort** and appears frequently in coding interviews.

In this article, we cover:

- Brute Force Approach  
- Better Approach  
- Optimal Pointer-Based Merge  
- JavaScript & Python Code  
- Example Visualization  
- Real-World Applications  
- Time & Space Complexity  

---

## ğŸªœ 1. Problem Definition

> **Given two sorted linked lists, merge them into a single sorted linked list and return the head.**

Example:

List A: `1 â†’ 3 â†’ 5`  
List B: `2 â†’ 4 â†’ 6`  

Output:  
`1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6`

---

## ğŸ¢ 2. Brute Force Approach (Convert to Array â†’ Sort â†’ Convert Back)

### **Idea**
- Traverse both lists  
- Push elements into an array  
- Sort the array  
- Build a new linked list from sorted values  

### **JavaScript Implementation**

```js
function mergeBruteForce(l1, l2) {
  const arr = [];
  let cur = l1;

  while (cur) {
    arr.push(cur.val);
    cur = cur.next;
  }

  cur = l2;
  while (cur) {
    arr.push(cur.val);
    cur = cur.next;
  }

  arr.sort((a, b) => a - b);

  // Rebuild linked list
  let dummy = new ListNode(0);
  let node = dummy;

  for (let val of arr) {
    node.next = new ListNode(val);
    node = node.next;
  }

  return dummy.next;
}
````

### **Complexity**

* â± Time: **O((n + m) log(n + m))**
* ğŸ’¾ Space: **O(n + m)**

<Callout type="warning">
This defeats the purpose of linked lists â€” too much extra memory.
</Callout>

---

## âš¡ 3. Better Approach â€” Recursion

### **Idea**

Choose the smaller of two heads, recurse for the rest.

### **JavaScript Implementation**

```js
function mergeRecursive(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1.val < l2.val) {
    l1.next = mergeRecursive(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeRecursive(l1, l2.next);
    return l2;
  }
}
```

### **Complexity**

* â± Time: **O(n + m)**
* ğŸ’¾ Space: **O(n + m)** (due to recursion call stack)

---

## ğŸ§  4. Optimal Approach â€” Iterative Pointer Merge

This is the **best and most memory-efficient approach**, used in merge sort.

### **Idea**

* Maintain two pointers on both lists
* Pick the smaller node each time
* Append it to the merged list
* Advance that pointer
* Continue until one list finishes

### **Why Optimal?**

* No extra arrays
* No recursion
* In-place merging

---

## âœ¨ Optimal Solution Code

### **JavaScript Implementation**

```js
function mergeTwoLists(l1, l2) {
  let dummy = new ListNode(0);
  let tail = dummy;

  while (l1 && l2) {
    if (l1.val < l2.val) {
      tail.next = l1;
      l1 = l1.next;
    } else {
      tail.next = l2;
      l2 = l2.next;
    }
    tail = tail.next;
  }

  // Attach remaining nodes
  tail.next = l1 || l2;

  return dummy.next;
}
```

### **Python Implementation**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode()
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    tail.next = l1 or l2

    return dummy.next
```

---

## ğŸ” 5. Example Walkthrough

List A:
`1 â†’ 3 â†’ 5`

List B:
`2 â†’ 4 â†’ 6`

Steps:

1. Compare 1 & 2 â†’ take 1
2. Compare 3 & 2 â†’ take 2
3. Compare 3 & 4 â†’ take 3
4. Continueâ€¦

Final:
`1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6`

<Callout type="success">
Merging happens in **strictly linear time** â€” no sorting needed.
</Callout>

---

## ğŸŒ 6. Real-World Use Cases

### **ğŸ§® 1. Merge Sort Algorithm**

Core step of merging sorted halves.

### **ğŸ§¾ 2. Combining Sorted Logs**

Merging sorted time-stamped events or server logs.

### **ğŸ“Š 3. Database Merge Operations**

Merging sorted query results efficiently.

### **ğŸ“‚ 4. File Systems**

File merging & ordered block tracking.

### **ğŸ“ˆ 5. Streaming Data**

Combine two sorted data streams in real-time.

---

## ğŸ“Š 7. Time & Space Complexity

| Approach                | Time Complexity   | Space Complexity |
| ----------------------- | ----------------- | ---------------- |
| Brute Force             | O((n+m) log(n+m)) | O(n+m)           |
| Recursive Merge         | O(n+m)            | O(n+m) (stack)   |
| Iterative Pointer Merge | O(n+m)            | O(1)             |

<Callout type="success">
Pointer-based merge is the **optimal**, interview-approved solution.
</Callout>

---

## ğŸ 8. Final Summary

* Brute force breaks linked list advantages
* Recursion is elegant but not memory optimal
* Iterative pointer merge is **best**
* Runs in **linear time O(n + m)** with **constant space**
* Essential for mastering merge sort & linked lists

---