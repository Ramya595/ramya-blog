---
title: "1ï¸âƒ£5ï¸âƒ£ Detect Cycle in Linked List â€” Floydâ€™s Cycle Detection (Tortoise & Hare)"
description: "Brute Force, Better, and Optimal approaches to detect a cycle in a linked list with real-world examples, code, explanation, and complexities."
---

#  Detect Cycle in Linked List  
**Category:** Linked List  
**Tags:** Floydâ€™s Algorithm, Two Pointers, Fast-Slow Pointer, Cycles

One of the most repeated interview questions for **FAANG**, and one of the easiest ways to check your understanding of **pointer manipulation**.

---

# ğŸ§  Problem Statement

Given the `head` of a linked list, return **true** if there is a cycle**, otherwise return false.**

A cycle exists if some node points back to a previous node.

---

# ğŸ§© Real-World Analogy  
### ğŸƒâ€â™‚ï¸ğŸ¢ Running Track (Tortoise & Hare)

Imagine two runners on a circular track:

- ğŸ¢ **Slow Runner** â†’ moves 1 step at a time  
- ğŸ‡ **Fast Runner** â†’ moves 2 steps at a time  

If the track is circular, the fast runner will eventually **lap** the slow runner.  
If the track is straight (no cycle), they will **never meet**.

This is exactly how Floydâ€™s Algorithm works.

---

# ğŸ¥‰ Approach 1 â€” Brute Force (Marking Visited Nodes)

### ğŸ› ï¸ Idea  
Keep a **set of visited nodes**.

### Steps  
1. Traverse linked list  
2. Store each node in a set  
3. If you reach a node youâ€™ve already visited â†’ cycle exists

### â— Why it's not good?  
- Requires extra memory  
- Not optimal for interviews

### â³ Time Complexity  
- **O(n)**

### ğŸ§  Space Complexity  
- **O(n)** â€” storing visited nodes

### ğŸ§ª Code
```js
function hasCycle(head) {
  let visited = new Set();

  while (head) {
    if (visited.has(head)) return true;
    visited.add(head);
    head = head.next;
  }

  return false;
}
````

---

# ğŸ¥ˆ Approach 2 â€” Modify Node Structure (Marking Nodes)

### âš ï¸ Not recommended in interviews

You can modify each visited node by marking it (e.g., setting a flag).

But this:

* Modifies original data (bad practice)
* Fails if nodes don't allow mutation

### â³ Time Complexity

* **O(n)**

### ğŸ§  Space Complexity

* **O(1)**
  (but modifies original list â€” unacceptable!)

---

# ğŸ¥‡ Approach 3 â€” Optimal (Floydâ€™s Cycle Detection Algorithm)

This is the **most important** and **most expected** solution.

### ğŸ”¥ Key Idea

Use two pointers:

* **slow** â†’ moves 1 step
* **fast** â†’ moves 2 steps

If they ever point to the **same node**, a cycle exists.
If `fast` reaches `null`, no cycle exists.

---

## ğŸ§ª Code (Optimal)

```js
function hasCycle(head) {
  if (!head || !head.next) return false;

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;         // 1 step
    fast = fast.next.next;    // 2 steps

    if (slow === fast) return true; // cycle detected
  }

  return false; // reached end -> no cycle
}
```

---

## ğŸ” Dry Run Example

List with cycle:

```
1 â†’ 2 â†’ 3 â†’ 4
        â†‘   â†“
        â†â†â†â†
```

| Step | Slow | Fast | Result                |
| ---- | ---- | ---- | --------------------- |
| 1    | 1    | 2    | continue              |
| 2    | 2    | 4    | continue              |
| 3    | 3    | 3    | slow === fast â†’ cycle |

---

# â³ Time Complexity

* **O(n)** â€” each pointer traverses at most n steps

# ğŸ§  Space Complexity

* **O(1)** â€” constant extra space
* Does not modify the list

---

# ğŸ Final Thoughts

Floydâ€™s Algorithm is optimal because:
âœ”ï¸ No extra memory
âœ”ï¸ Simple pointer movement
âœ”ï¸ Works in linear time
âœ”ï¸ Most expected in interviews

---