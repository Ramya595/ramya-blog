---
title: "1ï¸âƒ£Two Sum"
description: "Detailed brute force and optimal hashing-based solutions for the Two Sum problem with time/space complexities and real-world use cases."
date: "2025-11-21"
tags: ["dsa", "arrays", "hashmap", "interview", "javascript"]
---

# ğŸ¯ 1. Two Sum â€” Hashing to Find Pair in an Array

Two Sum is one of the most famous DSA problems.  
It tests your understanding of:

- Hashing  
- Complement logic  
- Time optimization  
- Array traversal  

This problem appears in almost every **FAANG** coding interview.

---

# ğŸ§© Problem Statement

Given an array of integers `nums` and an integer `target`,  
return the **indices** of the two numbers such that:

```

nums[i] + nums[j] = target

````

You may assume:

- Exactly one solution exists  
- Same element cannot be used twice  

---

## ğŸ§  Example

### Input:
```txt
nums = [2, 7, 11, 15]
target = 9
````

### Output:

```txt
[0, 1]
```

Because `2 + 7 = 9`.

---

# ğŸªœ Approaches

## âŒ 1. Brute Force Approach (Double Loop)

### **Idea**

Check every pair using two nested loops and return the first one that sums to the target.

### **Code (JavaScript)**

```js
function twoSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
}
```

### **Complexity**

| Metric | Value     |
| ------ | --------- |
| Time   | **O(nÂ²)** |
| Space  | **O(1)**  |

Simple but inefficient for large inputs.

---

## ğŸš€ 2. Optimal Approach â€” HashMap (One-Pass Hashing)

This is the most efficient and most commonly expected solution.

### **Idea**

Use a hash map:

* For each number:

  * Compute its **complement**: `target - nums[i]`
  * If complement exists in map â†’ we found the answer
  * Otherwise, store the current number and its index

This ensures every element is processed **only once**.

---

## ğŸ§‘â€ğŸ’» Code (JavaScript Optimal)

```js
function twoSum(nums, target) {
  const map = new Map(); // number â†’ index

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    if (map.has(complement)) {
      return [map.get(complement), i];
    }

    map.set(nums[i], i);
  }
}
```

---

# ğŸ§® Complexity

| Operation               | Time     | Space |
| ----------------------- | -------- | ----- |
| HashMap lookup + insert | **O(1)** | O(n)  |
| Total                   | **O(n)** | O(n)  |

---

# ğŸ” Why Hashing Works

HashMap gives **instant lookup** (constant time).
Instead of searching for complement in the entire array, we check the map in **O(1)**.

Brings time from **O(nÂ²) â†’ O(n)**.

---

# ğŸŒ Real-World Use Cases

### âœ” Fraud Detection

Detect if two transactions sum up to a flagged amount.

### âœ” E-commerce Discounts

Find two product prices that match a gift card balance.

### âœ” Finance

Pairing stock values, sums in portfolio balancing.

### âœ” Logistics

Load distribution: two packages matching weight target.

### âœ” Gaming

Matching two attack/defense values to reach a target result.

---

# ğŸ“Œ Summary Table

| Approach          | Time  | Space | Notes                       |
| ----------------- | ----- | ----- | --------------------------- |
| Brute Force       | O(nÂ²) | O(1)  | Easy but slow               |
| Hashing (Optimal) | O(n)  | O(n)  | â­ Most efficient & expected |

---

# ğŸ§© Final Thoughts

Two Sum teaches:

* HashMap fundamentals
* Complement-based logic
* Real-world lookup optimization
* Sets you up for similar problems:

  * 3 Sum
  * Subarray Sum
  * Pair with Given Difference

---