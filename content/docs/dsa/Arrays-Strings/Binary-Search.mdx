---
title: "2Ô∏è‚É£ Binary Search"
description: "Brute Force, Better Approach, and Optimal Approach for Binary Search with examples, code, time/space complexity."
---

import { Steps } from "fumadocs-ui";

# 2Ô∏è‚É£ Binary Search ‚Äî Efficient Searching in Sorted Arrays

Searching is one of the most common operations in computing.  
When your data is **sorted**, Binary Search gives you an ultra-fast way to find elements in **O(log n)** time.

This article walks through **Brute Force ‚Üí Better ‚Üí Optimal** approaches with explanations, real-world examples, and code.

---

## üöÄ Problem Statement
Given a **sorted array** and a **target value**, find the index of the target.  
If not found, return `-1`.

---

# üß† Approaches

## 1Ô∏è‚É£ Brute Force Approach
The simplest way ‚Äî check every element one by one.

### **Idea**
- Start from index `0`  
- Compare each element with the target  
- Stop when found

### **Code**
```js
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}
````

### **Time Complexity:**

* ‚è±Ô∏è `O(n)` ‚Äî checks each element

### **Space Complexity:**

* üì¶ `O(1)` ‚Äî no extra memory

### **Real-world example**

* Searching your name in an **unsorted** attendance list
* Scanning every product on a supermarket shelf

---

## 2Ô∏è‚É£ Better Approach (Using Built-in Methods)

Modern languages have optimized search routines.

### **Idea**

Use built-in search functions (like `indexOf`) that are internally optimized.

### **Code**

```js
function betterSearch(arr, target) {
  return arr.indexOf(target);
}
```

### **Time Complexity:**

* ‚è±Ô∏è `O(n)` (but usually slightly optimized internally)

### **Space Complexity:**

* üì¶ `O(1)`

### **Real-world example**

* Searching a song name in your **offline playlist**, where the app sequentially checks entries
* Searching for a keyword inside a text file

> ‚ö†Ô∏è This approach is not optimal for sorted arrays, but it's simpler and slightly better than manual loops.

---

## 3Ô∏è‚É£ Optimal Approach ‚Äî Binary Search üî•

### **Idea**

Instead of searching the whole array, repeatedly divide the array in half.

### **Steps**

<Steps>
  <Steps.Step>Check the middle element</Steps.Step>
  <Steps.Step>If target is smaller ‚Üí search left half</Steps.Step>
  <Steps.Step>If target is larger ‚Üí search right half</Steps.Step>
  <Steps.Step>Repeat until found or range becomes empty</Steps.Step>
</Steps>

### **Code**

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;

    if (target < arr[mid]) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return -1;
}
```

### **Time Complexity:**

* ‚è±Ô∏è `O(log n)` ‚Äî divides data in half every step

### **Space Complexity:**

* üì¶ `O(1)` ‚Äî iterative approach
  *(Recursive version costs O(log n) space)*

### **Real-world examples**

* Searching a word in a physical **dictionary**
* ‚ÄúGuess the Number‚Äù game using **higher/lower** logic
* Looking up entries in **phone books**, **database indexes**, **binary search trees**

---

# üìå Summary Table

| Approach    | Description        | Time         | Space |
| ----------- | ------------------ | ------------ | ----- |
| Brute Force | Check all elements | O(n)         | O(1)  |
| Better      | Built-in search    | O(n)         | O(1)  |
| Optimal     | Binary Search      | **O(log n)** | O(1)  |

---

# üß© Final Thoughts

Binary Search is a fundamental algorithm every developer must master.
It's faster, cleaner, and extremely powerful when working with **sorted data**.