---
title: "2️⃣ Binary Search"
description: "Learn Binary Search with brute force, better, and optimal approaches including real-world examples, time complexity, and space complexity."
date: "2025-11-21"
---

import { CodeBlock } from "@/components/CodeBlock"

# 2️⃣ Binary Search — Efficient Searching in Sorted Arrays

Binary Search is a classic algorithm to efficiently search for an element in a **sorted array**. Unlike linear search, it reduces the search space by half at each step.

Let’s break it down with **three approaches**.

---

## 1️⃣ Brute Force Approach

**Idea:** Check every element one by one until we find the target.

```js
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1; // element not found
}
````

**Time Complexity:** O(n) – Worst case, we may have to traverse the entire array.
**Space Complexity:** O(1) – No extra space needed.

**Real-world example:**
Looking for a name in an **unsorted guest list**. You must check each name one by one.

---

## 2️⃣ Better Approach — Binary Search (Iterative)

**Idea:**

* Works only on **sorted arrays**.
* Compare the middle element with the target:

  * If equal → Found
  * If target < middle → Search left half
  * If target > middle → Search right half

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) return mid;
    else if (target < arr[mid]) right = mid - 1;
    else left = mid + 1;
  }

  return -1; // element not found
}
```

**Time Complexity:** O(log n) – Each step halves the search space.
**Space Complexity:** O(1) – Only variables used.

**Real-world example:**
Searching for a **word in a dictionary**. You don’t check each word; you open near the middle and narrow down.

---

## 3️⃣ Optimal Approach — Binary Search (Recursive)

**Idea:** Same as iterative binary search but implemented recursively.

```js
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;

  let mid = Math.floor((left + right) / 2);

  if (arr[mid] === target) return mid;
  else if (target < arr[mid]) return binarySearchRecursive(arr, target, left, mid - 1);
  else return binarySearchRecursive(arr, target, mid + 1, right);
}
```

**Time Complexity:** O(log n) – Same efficiency as iterative.
**Space Complexity:** O(log n) – Recursive stack adds space usage.

**Real-world example:**
Finding a **specific record in a sorted database** using recursion to minimize iterative code.

---

### ⚡ Key Takeaways

* Always **sort the array** before using binary search.
* Iterative binary search is **space-efficient**.
* Recursive binary search is elegant but uses **extra stack space**.
* Binary search reduces **searching time drastically** compared to linear search.

---