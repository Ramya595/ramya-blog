---
title: "3ï¸âƒ£ Reverse a String / Array"
description: "Brute Force, Better, and Optimal approach for reversing strings/arrays with examples, code, and complexities."
---

# 3ï¸âƒ£ Reverse a String / Array â€” Pointer-based Reversal

Reversing a sequence is a classic DSA problem.  
Whether you're reversing a **string**, **array**, or **list**, the underlying logic improves your understanding of pointers and indexing.

This article explains all **3 approaches**:  
**Brute Force â†’ Better â†’ Optimal (Two Pointers)**  
with examples, complexities, and real-world use cases.

---

## ğŸš€ Problem Statement
Given a string or array, return the reversed version.

Example:  
`"hello"` â†’ `"olleh"`

---

# ğŸ§  Approaches

---

## 1ï¸âƒ£ Brute Force Approach (Using an Extra Array or String)

### **Idea**
- Traverse input from **end â†’ start**
- Append each character to a new string/array

### **Code (String)**
```js
function reverseBrute(str) {
  let result = "";
  for (let i = str.length - 1; i >= 0; i--) {
    result += str[i];
  }
  return result;
}
````

### **Code (Array)**

```js
function reverseArrayBrute(arr) {
  const result = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
}
```

### **Time Complexity**

â±ï¸ **O(n)** â€” iterates through all characters

### **Space Complexity**

ğŸ“¦ **O(n)** â€” uses extra array/string

### **Real-world Examples**

* Creating a **copy** of data in reversed order
* Reversing playback order in a primitive media player

---

## 2ï¸âƒ£ Better Approach (Built-in Methods)

Languages provide optimized reversing methods.

### **Idea**

Use built-in reverse APIs that are internally optimized.

### **Code (Array)**

```js
function reverseBetter(arr) {
  return arr.slice().reverse(); // slice() avoids mutating original
}
```

### **Code (String)**

```js
function reverseStringBetter(str) {
  return str.split("").reverse().join("");
}
```

### **Time Complexity**

â±ï¸ **O(n)**

### **Space Complexity**

ğŸ“¦ **O(n)** â€” because split + reverse + join create copies

### **Real-world Examples**

* Reversing chat history using internal `.reverse()`
* Quick UI manipulation using framework helpers

> ğŸ” Better, but still not the *best*. Uses extra memory.

---

## 3ï¸âƒ£ Optimal Approach â€” Two Pointer Technique (In-place) ğŸ”¥

### **Idea**

Swap characters from both ends â†’ move pointers inward.

### **Steps**

<Steps>
  <Steps.Step>Initialize left = 0, right = length - 1</Steps.Step>
  <Steps.Step>Swap characters at left and right</Steps.Step>
  <Steps.Step>Move left++ and right--</Steps.Step>
  <Steps.Step>Repeat until both pointers meet</Steps.Step>
</Steps>

### **Code (Array In-Place)**

```js
function reverseOptimal(arr) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
  return arr;
}
```

### **Code (String â†’ Convert to Array â†’ Reverse In-place)**

```js
function reverseStringOptimal(str) {
  const arr = str.split("");
  let left = 0, right = arr.length - 1;

  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
  return arr.join("");
}
```

### **Time Complexity**

â±ï¸ **O(n)**

### **Space Complexity**

ğŸ“¦ **O(1)** (for arrays)
ğŸ“¦ **O(n)** for strings (because strings are immutable in JS)

### **Real-world Examples**

* Reversing image pixel arrays for transformations
* Undoing user actions stored in a stack-like list
* Flipping data in-place for low-memory embedded systems

---

# ğŸ“Œ Summary Table

| Approach    | Description              | Time     | Space    |
| ----------- | ------------------------ | -------- | -------- |
| Brute Force | New array from endâ†’start | O(n)     | O(n)     |
| Better      | Built-in reverse         | O(n)     | O(n)     |
| Optimal     | Two pointers (in-place)  | **O(n)** | **O(1)** |

---

# ğŸ§© Final Thoughts

Pointer-based reversal is one of the simplest yet most powerful techniques.
It improves understanding of indexing, mutation, and in-place transformations â€” core skills for interviews and real-world engineering.