---
title: "5ï¸âƒ£Maximum Subarray (Kadaneâ€™s Algorithm) â€” Max Sum in an Array"
description: "Brute force, better approach, Kadaneâ€™s optimal algorithm, complexity analysis, real-world use cases, and JS/Python code examples."
tags:
  - DSA
  - Arrays
  - Kadane's Algorithm
  - Dynamic Programming
  - Problem Solving
---

import { Callout } from "fumadocs-ui/components/callout";

# ğŸ’¥ Maximum Subarray â€” Kadaneâ€™s Algorithm

The **Maximum Subarray Problem** asks you to find the **largest sum of any contiguous subarray** in a given array.  
Kadaneâ€™s Algorithm solves it in **O(n)** time and is one of the most famous dynamic programming techniques.

This article covers:

- Brute Force  
- Better Approach  
- Optimal Kadaneâ€™s Algorithm  
- JavaScript + Python Code  
- Example Walkthrough  
- Real-World Use Cases  
- Time & Space Complexity  

---

## ğŸªœ 1. Problem Definition

> **Given an integer array, find the contiguous subarray with the largest sum. Return the maximum sum.**

Example:

```js
Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Output: 6   // subarray: [4, -1, 2, 1]
````

---

## ğŸ¢ 2. Brute Force Approach (Check All Subarrays)

### **Idea**

Try every possible subarray and compute its sum.

### **JavaScript Implementation**

```js
function maxSubarrayBrute(arr) {
  let maxSum = -Infinity;

  for (let i = 0; i < arr.length; i++) {
    let currentSum = 0;
    for (let j = i; j < arr.length; j++) {
      currentSum += arr[j];
      maxSum = Math.max(maxSum, currentSum);
    }
  }

  return maxSum;
}
```

### **Complexity**

* â± Time: **O(nÂ²)**
* ğŸ’¾ Space: **O(1)**

<Callout type="warning">
Works but extremely slow for large arrays.
</Callout>

---

## âš¡ 3. Better Approach â€” Prefix Sum (Still Not Optimal)

### **Idea**

* Compute prefix sums
* Max subarray = `prefix[j] - prefix[i]`
* Still needs nested loops â†’ not ideal

### **JavaScript Implementation**

```js
function maxSubarrayPrefix(arr) {
  const prefix = [0];
  for (let i = 0; i < arr.length; i++) prefix.push(prefix[i] + arr[i]);

  let maxSum = -Infinity;

  for (let i = 0; i < prefix.length; i++) {
    for (let j = i + 1; j < prefix.length; j++) {
      maxSum = Math.max(maxSum, prefix[j] - prefix[i]);
    }
  }

  return maxSum;
}
```

### **Complexity**

* â± Time: **O(nÂ²)**
* ğŸ’¾ Space: **O(n)**

---

## ğŸ§  4. Optimal Approach â€” Kadaneâ€™s Algorithm (O(n))

Kadaneâ€™s Algorithm is based on a powerful idea:

> **At each index, decide whether to continue the current subarray or start a new one.**

### **Core Logic**

For each element:

* `currentSum = max(arr[i], currentSum + arr[i])`
* `maxSum = max(maxSum, currentSum)`

### Why it works?

* Negative sums reset the subarray
* Always track the highest sum seen so far

---

## âœ¨ Kadaneâ€™s Algorithm Code

### **JavaScript Implementation**

```js
function maxSubArrayKadane(arr) {
  let currentSum = arr[0];
  let maxSum = arr[0];

  for (let i = 1; i < arr.length; i++) {
    currentSum = Math.max(arr[i], currentSum + arr[i]);
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}
```

### **Python Implementation**

```python
def max_subarray_kadane(arr):
    current_sum = arr[0]
    max_sum = arr[0]

    for num in arr[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum
```

---

## ğŸ” 5. Example Walkthrough

Input:

```
[-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

Steps of `currentSum`:

```
-2 â†’ 1 â†’ -2 â†’ 4 â†’ 3 â†’ 5 â†’ 6 â†’ 1 â†’ 5
```

Max value = **6**

<Callout type="success">
Kadaneâ€™s Algorithm solves the problem in a single pass.
</Callout>

---

## ğŸŒ 6. Real-World Use Cases

### **ğŸ“ˆ 1. Stock Market Analysis**

Finding periods of maximum profit growth.

### **âœ¨ 2. Sensor Data / IoT Analytics**

Detecting most active activity streaks.

### **ğŸ® 3. Game Development**

Finding longest scoring streak or momentum sequences.

### **ğŸ§  4. Machine Learning**

Feature extraction from time series sequences.

### **ğŸ’» 5. Performance Monitoring**

Detecting peak CPU or network usage intervals.

---

## ğŸ“Š 7. Time & Space Complexity

| Approach           | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Brute Force        | O(nÂ²)           | O(1)             |
| Prefix Sum         | O(nÂ²)           | O(n)             |
| Kadaneâ€™s Algorithm | O(n)            | O(1)             |

<Callout type="success">
Kadaneâ€™s Algorithm is the **optimal** and most widely used solution.
</Callout>

---

## ğŸ 8. Final Summary

* Brute force generates all subarrays â†’ too slow
* Prefix-sum is better but still quadratic
* Kadaneâ€™s Algorithm gives **O(n)** performance
* Works for any integer array
* Widely applied in financial and time-series applications

---