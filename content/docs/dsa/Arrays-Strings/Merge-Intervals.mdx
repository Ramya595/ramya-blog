---
title: "1ï¸âƒ£2ï¸âƒ£ Merge Intervals â€” Overlapping Interval Merging"
description: "Brute Force, Better, and Optimal approaches for merging overlapping intervals with real-world examples, code, explanation, and complexities."
---

#  Merge Intervals  
**Category:** Arrays / Intervals  
**Tags:** Sorting, Greedy, Merging, Interval Problems

The **Merge Intervals** problem is one of the most frequently asked interview questions at **FAANG** companies.  
It teaches you how to handle **ranges**, **overlaps**, and **merging logic** using a clean greedy approach.

---

# ğŸ§  Problem Statement

Given an array of intervals where each interval is `[start, end]`, merge all intervals that **overlap**.

**Input:** `[[1,3], [2,6], [8,10], [15,18]]`  
**Output:** `[[1,6], [8,10], [15,18]]`

---

# ğŸ§© Real-World Analogy  
### ğŸ—‚ï¸ Example: Meeting Room Scheduler  
Imagine you manage meeting rooms in an office.

Meetings:  
- 9:00 â€“ 10:00  
- 9:30 â€“ 10:30  
- 11:00 â€“ 12:00  

The first two meetings overlap. You would treat them as:  
- **9:00 â€“ 10:30 (merged)**  
- 11:00 â€“ 12:00

This is exactly what the **Merge Intervals** algorithm does â€” combine overlapping time slots.

---

# ğŸ¥‰ Approach 1 â€” Brute Force (Check Every Pair)

### ğŸ› ï¸ Idea  
Compare every interval with every other interval to find overlaps, and merge repeatedly.

### â— Why it's not good?
- Requires checking all pairs  
- Complicated merging logic  
- Repeated scanning

### â³ Time Complexity  
- **O(nÂ²)** â€” compare each interval with all others

### ğŸ§  Space Complexity  
- **O(n)** â€” for storing merged intervals

### ğŸ§ª Code (Not recommended for interviews)
```js
function merge(intervals) {
  let merged = [];

  for (let i = 0; i < intervals.length; i++) {
    let [start1, end1] = intervals[i];
    for (let j = i + 1; j < intervals.length; j++) {
      let [start2, end2] = intervals[j];
      if (start2 <= end1 && end2 >= start1) {
        start1 = Math.min(start1, start2);
        end1 = Math.max(end1, end2);
      }
    }
    merged.push([start1, end1]);
  }

  return merged;
}
````

---

# ğŸ¥ˆ Approach 2 â€” Better (Using Sorting + Merging in New Array)

### ğŸ› ï¸ Idea

1. Sort intervals based on start time.
2. Create a new array.
3. Compare each interval and merge if overlapping.

This is cleaner and commonly used.

### ğŸ§ª Code

```js
function merge(intervals) {
  intervals.sort((a, b) => a[0] - b[0]);

  let result = [];
  let current = intervals[0];

  for (let i = 1; i < intervals.length; i++) {
    let interval = intervals[i];

    // Overlap
    if (interval[0] <= current[1]) {
      current[1] = Math.max(current[1], interval[1]);
    } else {
      result.push(current);
      current = interval;
    }
  }

  result.push(current);
  return result;
}
```

### â³ Time Complexity

* Sorting: **O(n log n)**
* Merging: **O(n)**
* **Total: O(n log n)**

### ğŸ§  Space Complexity

* **O(n)** â€” because we store merged output separately

---

# ğŸ¥‡ Approach 3 â€” Optimal (Greedy In-Place Merging)

This approach is identical to the better approach but optimized for **in-place merging** (space: O(1) additional).

### ğŸ”¥ Key Idea

* Sort intervals
* Use "previous interval" as reference
* Merge in-place without storing separately
* Only append when necessary

### ğŸ§ª Code (Optimal)

```js
function merge(intervals) {
  intervals.sort((a, b) => a[0] - b[0]);

  let index = 0; // points to the last merged interval

  for (let i = 1; i < intervals.length; i++) {
    let prev = intervals[index];
    let curr = intervals[i];

    if (curr[0] <= prev[1]) {
      // merge
      prev[1] = Math.max(prev[1], curr[1]);
    } else {
      // move to next interval
      index++;
      intervals[index] = curr;
    }
  }

  return intervals.slice(0, index + 1);
}
```

---

## ğŸ” Dry Run Example

Input:

```
[[1,3],[2,6],[8,10],[15,18]]
```

| Step | Current | Last Merged | Action                   |
| ---- | ------- | ----------- | ------------------------ |
| 1    | [1,3]   | [1,3]       | Start                    |
| 2    | [2,6]   | [1,3]       | Overlap â†’ merge to [1,6] |
| 3    | [8,10]  | [1,6]       | No overlap â†’ add new     |
| 4    | [15,18] | [8,10]      | No overlap â†’ add new     |

Final:
`[[1,6], [8,10], [15,18]]`

---

# â³ Time Complexity

* **O(n log n)** â€” sorting dominates

# ğŸ§  Space Complexity

* **O(1)** extra space (optimal)
* **O(n)** space for output (if using better approach)

---

# ğŸ Final Thoughts

The **Merge Intervals** problem teaches you how to:

* Work with **ranges and boundaries**
* Think using **sorting + greedy logic**
* Write efficient in-place solutions

### â­ Interview Tip

Always sort first, then merge â€” this guarantees correctness.

---