---
title: "1ï¸âƒ£3ï¸âƒ£ Group Anagrams â€” Hashing + String Manipulation"
description: "Brute Force, Better, and Optimal approaches to group anagrams with real-world examples, code, explanation, and complexities."
---

#  Group Anagrams  
**Category:** Strings / Hashing  
**Tags:** Anagrams, HashMap, Frequency Count, Grouping

"Group Anagrams" is one of the most commonly asked interview problems at **Google, Amazon, Microsoft**, and startups.  
It tests your understanding of **string manipulation**, **hashing**, and **efficient grouping**.

---

# ğŸ§  Problem Statement

Given an array of strings, group the words that are **anagrams** of each other.

**Input:**  
`["eat", "tea", "tan", "ate", "nat", "bat"]`

**Output:**  
`[["eat","tea","ate"], ["tan","nat"], ["bat"]]`

---

# ğŸ§© Real-World Analogy  

### ğŸ½ï¸ Restaurant Ordering System (Anagram Bins)

Imagine each word is an order slip in a restaurant.

- â€œeatâ€, â€œteaâ€, â€œateâ€ â†’ same letters â†’ same bin  
- â€œtanâ€, â€œnatâ€ â†’ same bin  
- â€œbatâ€ â†’ stays alone

Just like organizing kitchen orders by ingredients, grouping anagrams means putting words with the **same characters** together.

---

# ğŸ¥‰ Approach 1 â€” Brute Force  
### ğŸ› ï¸ Idea  
For each word, check all other words to see if they are anagrams.

### â— Why this is bad?  
- Checking anagram equality requires sorting or frequency matching.  
- Comparing each word with every other â†’ too slow.

### â³ Time Complexity  
- **O(nÂ² * k log k)**  
  - n = number of words  
  - k = length of each word  

### ğŸ§  Space Complexity  
- **O(1)** (ignoring output list)

### ğŸ§ª Code (Not recommended)
```js
function groupAnagrams(strs) {
  let used = new Array(strs.length).fill(false);
  let result = [];

  for (let i = 0; i < strs.length; i++) {
    if (used[i]) continue;

    let group = [strs[i]];
    used[i] = true;

    for (let j = i + 1; j < strs.length; j++) {
      if (!used[j] && isAnagram(strs[i], strs[j])) {
        group.push(strs[j]);
        used[j] = true;
      }
    }

    result.push(group);
  }

  return result;
}

function isAnagram(a, b) {
  return a.split("").sort().join("") === b.split("").sort().join("");
}
````

---

# ğŸ¥ˆ Approach 2 â€” Better (Sorting Each Word)

### ğŸ› ï¸ Idea

Two anagrams have the **same sorted string**.

Example:

* `eat` â†’ `aet`
* `tea` â†’ `aet`
* `ate` â†’ `aet`

So use the sorted word as a **key** in a map.

### ğŸ§ª Code

```js
function groupAnagrams(strs) {
  let map = new Map();

  for (let word of strs) {
    let sorted = word.split("").sort().join("");

    if (!map.has(sorted)) map.set(sorted, []);
    map.get(sorted).push(word);
  }

  return Array.from(map.values());
}
```

### â³ Time Complexity

* Sorting each word: **O(k log k)**
* For n words: **O(n * k log k)**

### ğŸ§  Space Complexity

* **O(n * k)** â€” storing grouped words

### âœ”ï¸ Good approach

But not the most optimal since sorting each word costs time.

---

# ğŸ¥‡ Approach 3 â€” Optimal (Character Frequency Hashing)

### ğŸ”¥ Key Idea

Instead of sorting, create a **frequency signature** based on characters.

For "eat":

| Letter | e | a | t |
| ------ | - | - | - |
| Count  | 1 | 1 | 1 |

Represent it as a compact signature string:
`"1#1#1#0#0#...#"`

This makes grouping **O(k)** per word instead of **O(k log k)**.

### ğŸ§ª Code (Optimal)

```js
function groupAnagrams(strs) {
  let map = new Map();

  for (let word of strs) {
    let freq = new Array(26).fill(0);
    for (let ch of word) {
      freq[ch.charCodeAt(0) - 97]++;
    }

    let key = freq.join('#');

    if (!map.has(key)) map.set(key, []);
    map.get(key).push(word);
  }

  return Array.from(map.values());
}
```

---

## ğŸ” Dry Run Example

Input:

```
["eat","tea","tan","ate","nat","bat"]
```

| Word | Signature | Group   |
| ---- | --------- | ------- |
| eat  | 1#1#1#... | Group 1 |
| tea  | 1#1#1#... | Group 1 |
| ate  | 1#1#1#... | Group 1 |
| tan  | 1#0#1#... | Group 2 |
| nat  | 1#0#1#... | Group 2 |
| bat  | 1#1#0#... | Group 3 |

---

# â³ Time Complexity

* Creating frequency count: **O(k)**
* For n words: **O(n * k)**
* Faster than sorting-based.

# ğŸ§  Space Complexity

* **O(n * k)**

---

# ğŸ Final Thoughts

The **frequency-hash method** is the best and most scalable:

### âœ”ï¸ No sorting

### âœ”ï¸ Fast grouping

### âœ”ï¸ Best for very large datasets

This problem strengthens skills in:

* Hashing
* String manipulation
* Optimization of naive approaches

---