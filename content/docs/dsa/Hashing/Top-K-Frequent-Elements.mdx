---
title: "1Ô∏è‚É£4Ô∏è‚É£ Top K Frequent Elements ‚Äî Frequency Map + Heap + Bucket Sort"
description: "Brute Force, Better, and Optimal approaches to find top K frequent elements with real-world examples, code, explanation, and complexities."
---

# 14Ô∏è‚É£ Top K Frequent Elements  
**Category:** Arrays / Hashing / Heaps  
**Tags:** Frequency Map, Bucket Sort, Max Heap, Counting

The **Top K Frequent Elements** problem is extremely common in interviews for **FAANG** companies.  
It tests your ability to work with **frequency counts**, **priority queues**, and **bucket sorting**.

---

# üß† Problem Statement

Given an integer array `nums` and an integer `k`, return the **k most frequent elements**.

**Input:**  
`nums = [1,1,1,2,2,3], k = 2`

**Output:**  
`[1, 2]`

---

# üß© Real-World Analogy  
### üì± Finding Most Used Apps on Your Phone

Your phone tracks how many times each app is opened:

- WhatsApp ‚Üí 120 times  
- Instagram ‚Üí 95 times  
- Chrome ‚Üí 40 times  
- Camera ‚Üí 20 times  

If you want the **top 2 most used apps**, you pick:  
üëâ WhatsApp & Instagram.

This is exactly what ‚ÄúTop K Frequent Elements‚Äù does ‚Äî finds the most repeated items.

---

# ü•â Approach 1 ‚Äî Brute Force (Using Sorting)  

### üõ†Ô∏è Idea  
1. Count frequency of each number.  
2. Convert map to array.  
3. Sort by frequency in descending order.  
4. Return first k elements.

### ‚è≥ Time Complexity  
- Frequency map: **O(n)**  
- Sorting: **O(n log n)**  
- Total: **O(n log n)**

### üß† Space Complexity  
- **O(n)**

### üß™ Code
```js
function topKFrequent(nums, k) {
  let freq = new Map();

  for (let num of nums) {
    freq.set(num, (freq.get(num) || 0) + 1);
  }

  let arr = [...freq.entries()];
  arr.sort((a, b) => b[1] - a[1]);

  return arr.slice(0, k).map(x => x[0]);
}
````

---

# ü•à Approach 2 ‚Äî Better (Using Max-Heap)

### üõ†Ô∏è Idea

Use a **priority queue (max heap)** where the highest frequency stays on top.

### Steps

1. Build frequency map
2. Push each element into a max heap
3. Extract top k

### ‚è≥ Time Complexity

* Building heap: **O(n)**
* Extracting k elements: **O(k log n)**
* Total: **O(n + k log n)**

### üß† Space Complexity

* **O(n)**

### üß™ Code (Using custom heap for JS)

```js
class MaxHeap {
  constructor() {
    this.data = [];
  }
  push(val) {
    this.data.push(val);
    this._heapifyUp();
  }
  pop() {
    if (this.size() === 1) return this.data.pop();
    let top = this.data[0];
    this.data[0] = this.data.pop();
    this._heapifyDown();
    return top;
  }
  size() {
    return this.data.length;
  }
  _heapifyUp() {
    let i = this.size() - 1;
    while (i > 0) {
      let p = Math.floor((i - 1) / 2);
      if (this.data[p][1] >= this.data[i][1]) break;
      [this.data[p], this.data[i]] = [this.data[i], this.data[p]];
      i = p;
    }
  }
  _heapifyDown() {
    let i = 0;
    while (true) {
      let left = i * 2 + 1;
      let right = i * 2 + 2;
      let largest = i;

      if (left < this.size() && this.data[left][1] > this.data[largest][1]) {
        largest = left;
      }
      if (right < this.size() && this.data[right][1] > this.data[largest][1]) {
        largest = right;
      }
      if (largest === i) break;
      [this.data[i], this.data[largest]] = [this.data[largest], this.data[i]];
      i = largest;
    }
  }
}

function topKFrequent(nums, k) {
  let freq = new Map();
  for (let n of nums) freq.set(n, (freq.get(n) || 0) + 1);

  let heap = new MaxHeap();
  for (let [num, count] of freq.entries()) {
    heap.push([num, count]);
  }

  let result = [];
  while (k--) result.push(heap.pop()[0]);

  return result;
}
```

---

# ü•á Approach 3 ‚Äî Optimal (Bucket Sort Method)

This is the fastest and most efficient solution.

### üî• Key Idea

* Maximum frequency of any number = **n**
* Create an array `buckets` where index represents frequency
* Put numbers inside their corresponding frequency bucket
* Collect from highest bucket until k elements found

---

## üß™ Code (Optimal: O(n))

```js
function topKFrequent(nums, k) {
  let freq = new Map();

  for (let num of nums) {
    freq.set(num, (freq.get(num) || 0) + 1);
  }

  let buckets = Array(nums.length + 1).fill(null).map(() => []);

  for (let [num, count] of freq.entries()) {
    buckets[count].push(num);
  }

  let result = [];

  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {
    if (buckets[i].length > 0) {
      result.push(...buckets[i]);
    }
  }

  return result.slice(0, k);
}
```

---

## üîç Dry Run Example

Input:

```
nums = [1,1,1,2,2,3], k = 2
```

| Number | Count | Bucket Index |
| ------ | ----- | ------------ |
| 1      | 3     | 3            |
| 2      | 2     | 2            |
| 3      | 1     | 1            |

Buckets:

* 3 ‚Üí [1]
* 2 ‚Üí [2]
* 1 ‚Üí [3]

Collect from top ‚Üí `[1, 2]`

---

# ‚è≥ Time Complexity

### Brute Force

* **O(n log n)**

### Heap

* **O(n + k log n)**

### Optimal (Bucket Sort)

* **O(n)** ‚Äî Best and expected in interviews

# üß† Space Complexity

* **O(n)** for buckets + frequency map

---

# üèÅ Final Thoughts

The **Bucket Sort approach** is the optimal way:

* No sorting
* Faster than heap
* Perfect for large inputs

### ‚≠ê Interview Tip

Always mention all three approaches, then say:

> ‚ÄúThe optimal solution uses bucket sort because the max frequency is at most n.‚Äù

---