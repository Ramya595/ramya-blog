---
title: "1ï¸âƒ£6ï¸âƒ£ Min Stack"
description: "Brute force, better, and optimal approach to design a Min Stack â€” always return minimum element in O(1). Includes real-world examples, code, and complexity."
---

#  Min Stack â€” Design a Stack That Returns Minimum in O(1)

A **Min Stack** is a special stack that supports:

- `push(x)`
- `pop()`
- `top()`
- `getMin()` â†’ returns **minimum element in constant time O(1)**

This is a very common **DSA + System Design** interview problem because it tests:
- data structure design
- time/space efficiency
- thinking beyond basic stacks

---

## ğŸ§  Real-World Examples

### ğŸ¦ 1. Banking / Wallet Systems  
Track the **minimum transaction amount** over time efficiently.

### ğŸ“‰ 2. Stock Market Price Monitoring  
Find the **minimum stock price** up to the current day.

### ğŸ® 3. Game Development  
Track **minimum health points** or **minimum scores** in a stack of moves.

---

---

# ğŸŒ Brute Force Solution â€” O(n) getMin()

### ğŸ§© Idea
Every time `getMin()` is called â†’ **iterate through the entire stack** and find the smallest value.

### âŒ Why it's bad?
- Slow `getMin()` â†’ **O(n)** per call.
- Interviewers expect **O(1)** `getMin()`.

### âœ… Code

```js
class MinStack {
  constructor() {
    this.stack = [];
  }

  push(x) {
    this.stack.push(x);
  }

  pop() {
    return this.stack.pop();
  }

  top() {
    return this.stack[this.stack.length - 1];
  }

  getMin() {
    let min = Infinity;
    for (let val of this.stack) {
      min = Math.min(min, val);
    }
    return min;
  }
}
````

### â±ï¸ Time & Space

| Operation  | Time   | Space |
| ---------- | ------ | ----- |
| push       | O(1)   | O(n)  |
| pop        | O(1)   | O(n)  |
| **getMin** | âŒ O(n) | O(n)  |

---

---

# ğŸ§ª Better Approach â€” Store Min So Far Alongside Value

### ğŸ§© Idea

Instead of scanning the whole stack, store **current minimum** with each element.

Example stack (value, minSoFar):

```
push 5 â†’ (5,5)
push 3 â†’ (3,3)
push 8 â†’ (8,3)
push 2 â†’ (2,2)
```

The top element always holds the **min so far** at that time.

### ğŸ‘ Improvement

* All operations â†’ **O(1)**
* Space used â†’ **O(n)** (duplicate mins stored)

### Code

```js
class MinStack {
  constructor() {
    this.stack = [];
  }

  push(x) {
    if (this.stack.length === 0) {
      this.stack.push([x, x]);
    } else {
      let currentMin = this.stack[this.stack.length - 1][1];
      this.stack.push([x, Math.min(x, currentMin)]);
    }
  }

  pop() {
    this.stack.pop();
  }

  top() {
    return this.stack[this.stack.length - 1][0];
  }

  getMin() {
    return this.stack[this.stack.length - 1][1];
  }
}
```

### â±ï¸ Time & Space

| Operation | Time | Space  |
| --------- | ---- | ------ |
| push      | O(1) | âŒ O(n) |
| pop       | O(1) | O(n)   |
| getMin    | O(1) | O(n)   |

---

---

# âš¡ Optimal Approach â€” Use Two Stacks

### ğŸ§© Idea

Use:

1ï¸âƒ£ **Main Stack** â†’ store values
2ï¸âƒ£ **Min Stack** â†’ store only values that represent new minimums

### Example

```
push 5 â†’ minStack: [5]
push 3 â†’ minStack: [5,3]
push 8 â†’ minStack: [5,3]
push 2 â†’ minStack: [5,3,2]
pop 2 â†’ remove from both
```

### Why this is optimal?

* No redundant "min" storage
* Only push to min-stack **when needed**
* Space-efficient

### Code

```js
class MinStack {
  constructor() {
    this.stack = [];
    this.minStack = [];
  }

  push(x) {
    this.stack.push(x);
    if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {
      this.minStack.push(x);
    }
  }

  pop() {
    let popped = this.stack.pop();
    if (popped === this.minStack[this.minStack.length - 1]) {
      this.minStack.pop();
    }
  }

  top() {
    return this.stack[this.stack.length - 1];
  }

  getMin() {
    return this.minStack[this.minStack.length - 1];
  }
}
```

---

## ğŸ Final Complexity

| Operation  | Time     | Space    |
| ---------- | -------- | -------- |
| push       | O(1)     | **O(n)** |
| pop        | O(1)     | O(n)     |
| top        | O(1)     | O(n)     |
| **getMin** | **O(1)** | O(n)     |

This is the **most optimal approach**, accepted in all coding interviews.

---

## ğŸ¯ Interview Tips

* Always explain **why O(1) getMin is required**.
* Mention the **two-stack optimal pattern**.
* Discuss **space trade-offs**.
* Give **real-world examples** to stand out.

---